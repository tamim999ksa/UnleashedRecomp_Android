--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -20,8 +20,10 @@

 project ("XenonRecomp-ALL")

-add_subdirectory(${XENONANALYSE_ROOT})
-add_subdirectory(${XENONRECOMP_ROOT})
+if (NOT ANDROID)
+    add_subdirectory(${XENONANALYSE_ROOT})
+    add_subdirectory(${XENONRECOMP_ROOT})
+endif()
 add_subdirectory(${XENONUTILS_ROOT})

 # Only tests if this is the top level project
--- a/XenonRecomp/recompiler.cpp
+++ b/XenonRecomp/recompiler.cpp
@@ -12,6 +12,7 @@

 bool Recompiler::LoadConfig(const std::string_view& configFilePath)
 {
+    fmt::println("Loading config from: {}", configFilePath);
     config.Load(configFilePath);

     std::vector<uint8_t> file;
@@ -83,7 +84,19 @@
             }
             else
             {
-                fmt::println("ERROR: Unable to load the patch file");
+                const auto fullPath = config.directoryPath + config.patchFilePath;
+                fmt::println("ERROR: Unable to load the patch file: {}", fullPath);
+
+                std::error_code ec;
+                if (std::filesystem::exists(fullPath, ec))
+                {
+                    auto fileSize = std::filesystem::file_size(fullPath, ec);
+                    fmt::println("File exists. Size: {} bytes", fileSize);
+                }
+                else
+                {
+                    fmt::println("File does not exist. Error: {}", ec.message());
+                }
                 return false;
             }
         }
--- a/XenonUtils/xbox.h
+++ b/XenonUtils/xbox.h
@@ -247,7 +247,7 @@
         {
             be<uint32_t> Error;
             be<uint32_t> Length;
-        };
+        } _ErrorLength;

         struct
         {
@@ -359,7 +359,17 @@
 // Direct reflection of XInput structures

 #define XAMINPUT_DEVTYPE_GAMEPAD          0x01
+#define XAMINPUT_DEVSUBTYPE_UNKNOWN       0x00
 #define XAMINPUT_DEVSUBTYPE_GAMEPAD       0x01
+#define XAMINPUT_DEVSUBTYPE_WHEEL         0x02
+#define XAMINPUT_DEVSUBTYPE_ARCADE_STICK  0x03
+#define XAMINPUT_DEVSUBTYPE_FLIGHT_STICK  0x04
+#define XAMINPUT_DEVSUBTYPE_DANCE_PAD     0x05
+#define XAMINPUT_DEVSUBTYPE_GUITAR        0x06
+#define XAMINPUT_DEVSUBTYPE_GUITAR_ALTERNATE 0x07
+#define XAMINPUT_DEVSUBTYPE_DRUM_KIT      0x08
+#define XAMINPUT_DEVSUBTYPE_GUITAR_BASS   0x0B
+#define XAMINPUT_DEVSUBTYPE_ARCADE_PAD    0x13

 #define XAMINPUT_GAMEPAD_DPAD_UP          0x0001
 #define XAMINPUT_GAMEPAD_DPAD_DOWN        0x0002
--- a/XenonUtils/xex_patcher.cpp
+++ b/XenonUtils/xex_patcher.cpp
@@ -16,6 +16,7 @@
 #include <cassert>
 #include <climits>
 #include <fstream>
+#include <iostream>

 #include <aes.hpp>
 #include <lzx.h>
@@ -305,7 +306,8 @@
     int resultCode = lzxDeltaApplyPatch(&patchDescriptor->info, patchDescriptor->size, ((const Xex2FileNormalCompressionInfo*)(patchFileFormatInfo + 1))->windowSize, outBytes.data());
     if (resultCode != 0)
     {
-        return Result::PatchFailed;
+        std::cerr << "lzxDeltaApplyPatch failed: " << resultCode << std::endl;
+        return Result::PatchDeltaFailed;
     }

     // Make the header the specified size by the patch.
@@ -432,7 +434,10 @@
             s.finalize(blockCalcedDigest);

             if (memcmp(blockCalcedDigest, blocks->blockHash, 0x14) != 0)
-                return Result::PatchFailed;
+            {
+                std::cerr << "Hash mismatch in base xex block!" << std::endl;
+                return Result::PatchHashMismatch;
+            }

             p += 4;
             p += 20;
@@ -461,7 +466,10 @@
         resultCode = lzxDecompress(compressBuffer.get(), d - compressBuffer.get(), buffer, uncompressedSize, ((const Xex2FileNormalCompressionInfo*)(fileFormatInfo + 1))->windowSize, nullptr, 0);

         if (resultCode)
-            return Result::PatchFailed;
+        {
+            std::cerr << "lzxDecompress failed: " << resultCode << std::endl;
+            return Result::PatchDecompressionFailed;
+        }
     }
     else if (fileFormatInfo->compressionType == XEX_COMPRESSION_DELTA)
     {
@@ -475,6 +483,7 @@
     Xex2OptFileFormatInfo *newFileFormatInfo = (Xex2OptFileFormatInfo *)(getOptHeaderPtr(outBytes.data(), XEX_HEADER_FILE_FORMAT_INFO));
     if (newFileFormatInfo == nullptr)
     {
+        std::cerr << "Could not find file format info in new xex!" << std::endl;
         return Result::PatchFailed;
     }

@@ -518,6 +527,8 @@
         sha1Context.finalize(sha1Digest);
         if (memcmp(sha1Digest, currentBlock->blockHash, DigestSize) != 0)
         {
+            std::cerr << "Hash mismatch in patch block!" << std::endl;
+            return Result::PatchHashMismatch;
             return Result::PatchFailed;
         }

@@ -527,7 +538,8 @@
         uint32_t blockDataSize = currentBlock->blockSize - 24;
         if (lzxDeltaApplyPatch((const Xex2DeltaPatch *)(patchDataCursor), blockDataSize, ((const Xex2FileNormalCompressionInfo*)(patchFileFormatInfo + 1))->windowSize, outExe) != 0)
         {
-            return Result::PatchFailed;
+            std::cerr << "lzxDeltaApplyPatch failed for patch block!" << std::endl;
+            return Result::PatchDeltaFailed;
         }

         patchDataCursor += blockDataSize;
--- a/XenonUtils/xex_patcher.h
+++ b/XenonUtils/xex_patcher.h
@@ -29,7 +29,10 @@
         PatchFileInvalid,
         PatchIncompatible,
         PatchFailed,
-        PatchUnsupported
+        PatchUnsupported,
+        PatchHashMismatch,
+        PatchDecompressionFailed,
+        PatchDeltaFailed
     };

     static Result apply(const uint8_t* xexBytes, size_t xexBytesSize, const uint8_t* patchBytes, size_t patchBytesSize, std::vector<uint8_t> &outBytes, bool skipData);
--- a/thirdparty/disasm/ppc-dis.c
+++ b/thirdparty/disasm/ppc-dis.c
@@ -5765,9 +5765,9 @@
             else if ((operand->flags & PPC_OPERAND_VR) != 0)
                 stream = stream + sprintf(stream, "v%ld", value);
             else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0)
-                stream = stream + sprintf(stream, "0x%llx", memaddr + value);
+                stream = stream + sprintf(stream, "0x%llx", (unsigned long long)(memaddr + value));
             else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
-                stream = stream + sprintf(stream, "0x%llx", (bfd_vma)value & 0xffffffff);
+                stream = stream + sprintf(stream, "0x%llx", (unsigned long long)((bfd_vma)value & 0xffffffff));
             else if ((operand->flags & PPC_OPERAND_CR) == 0
                 || (dialect & PPC_OPCODE_PPC) == 0)
                 stream = stream + sprintf(stream, "%ld", value);
--- a/XenonRecomp/test_recompiler.cpp
+++ b/XenonRecomp/test_recompiler.cpp
@@ -1,4 +1,5 @@
 #include "test_recompiler.h"
+#include <cctype>

 void TestRecompiler::Analyse(const std::string_view& testName)
 {
@@ -213,7 +214,24 @@
                                         int secondSpaceIndex = str.find(' ', spaceIndex + 1);
                                         auto reg = str.substr(spaceIndex + 1, secondSpaceIndex - spaceIndex - 1);
                                         if (reg[0] == 'c')
-                                            continue; // TODO
+                                            {
+                                            if (reg == "ctr")
+                                            {
+                                                fmt::println(file, "\tPPC_CHECK_VALUE_U({}, ctx.ctr.u64, 0x{});", name, str.substr(secondSpaceIndex + 1));
+                                            }
+                                            else if (reg.size() >= 2 && reg[1] == 'r')
+                                            {
+                                                if (reg.size() == 3 && isdigit(reg[2]))
+                                                {
+                                                    fmt::println(file, "\tPPC_CHECK_VALUE_U({}, ((ctx.{}.lt << 3) | (ctx.{}.gt << 2) | (ctx.{}.eq << 1) | ctx.{}.so), 0x{});", name, reg, reg, reg, reg, str.substr(secondSpaceIndex + 1));
+                                                }
+                                                else if (reg == "cr")
+                                                {
+                                                    fmt::println(file, "\tPPC_CHECK_VALUE_U({}, ((((ctx.cr0.lt << 3) | (ctx.cr0.gt << 2) | (ctx.cr0.eq << 1) | ctx.cr0.so) << 28) | (((ctx.cr1.lt << 3) | (ctx.cr1.gt << 2) | (ctx.cr1.eq << 1) | ctx.cr1.so) << 24) | (((ctx.cr2.lt << 3) | (ctx.cr2.gt << 2) | (ctx.cr2.eq << 1) | ctx.cr2.so) << 20) | (((ctx.cr3.lt << 3) | (ctx.cr3.gt << 2) | (ctx.cr3.eq << 1) | ctx.cr3.so) << 16) | (((ctx.cr4.lt << 3) | (ctx.cr4.gt << 2) | (ctx.cr4.eq << 1) | ctx.cr4.so) << 12) | (((ctx.cr5.lt << 3) | (ctx.cr5.gt << 2) | (ctx.cr5.eq << 1) | ctx.cr5.so) << 8) | (((ctx.cr6.lt << 3) | (ctx.cr6.gt << 2) | (ctx.cr6.eq << 1) | ctx.cr6.so) << 4) | (((ctx.cr7.lt << 3) | (ctx.cr7.gt << 2) | (ctx.cr7.eq << 1) | ctx.cr7.so) << 0)), 0x{});", name, str.substr(secondSpaceIndex + 1));
+                                                }
+                                            }
+                                            continue;
+                                        }
                                         if (reg[0] == 'v')
                                         {
                                             int openingBracketIndex = str.find('[', secondSpaceIndex + 1);
--- a/XenonUtils/CMakeLists.txt
+++ b/XenonUtils/CMakeLists.txt
@@ -30,3 +30,7 @@
     PUBLIC
         disasm
 )
+
+if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
+    target_compile_options(XenonUtils PRIVATE -fms-extensions)
+endif()
\ No newline at end of file
--- a/XenonUtils/xdbf.h
+++ b/XenonUtils/xdbf.h
@@ -132,7 +132,7 @@
     {
         be<uint16_t> u16;
         char u8[0x02];
-    };
+    } AsU16;

     be<uint32_t> u32;
 };
